-- Core tables
create table t_crypto_assets (
    id bigint generated by default as identity primary key,
    symbol text not null unique,
    name text not null,
    apiTicker text not null,
    logo_url text,
    is_active boolean default true,
    created_at timestamptz default now()
);

create table t_prediction_periods (
    id bigint generated by default as identity primary key,
    asset_id bigint references t_crypto_assets(id),
    starts_at timestamptz not null,
    ends_at timestamptz not null,
    is_active boolean default true,
    buy_in float not null default 1.0,
    total_pool float default 0,
    current_price numeric(20,8),
    current_high numeric(20,8),
    current_low numeric(20,8),
    final_high numeric(20,8),
    final_low numeric(20,8),
    closed_at timestamptz,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

create table t_prize_distributions (
    id bigint generated by default as identity primary key,
    period_id bigint references t_prediction_periods(id),
    winner_wallet_address text not null,
    prize_amount float not null,
    ton_transaction_hash text unique,
    status text not null default 'pending',
    created_at timestamptz default now(),
    completed_at timestamptz
);

create table t_user_predictions (
    id bigint generated by default as identity primary key,
    wallet_address text not null,
    period_id bigint references t_prediction_periods(id),
    predicted_high numeric(20,8) not null,
    predicted_low numeric(20,8) not null,
    ton_transaction_hash text not null unique,
    high_difference numeric(20,8),
    low_difference numeric(20,8),
    total_difference numeric(20,8),
    created_at timestamptz default now()
);

-- Functions for game management
create or replace function submit_prediction(
    p_wallet_address text,
    p_period_id bigint,
    p_predicted_high numeric(20,8),
    p_predicted_low numeric(20,8),
    p_ton_transaction_hash text
)
returns t_user_predictions language plpgsql as $$
declare
    v_period t_prediction_periods;
    v_prediction t_user_predictions;
begin
    -- Check if period exists and is active
    select *
    into v_period
    from t_prediction_periods
    where id = p_period_id
    and is_active = true
    and starts_at <= now()
    and ends_at > now();
    
    if v_period is null then
        raise exception 'Invalid or inactive prediction period';
    end if;
    
    -- Validate prediction values
    if p_predicted_low >= p_predicted_high then
        raise exception 'Predicted low must be less than predicted high';
    end if;
    
    -- Create prediction and update pool
    insert into t_user_predictions (
        wallet_address,
        period_id,
        predicted_high,
        predicted_low,
        ton_transaction_hash
    ) values (
        p_wallet_address,
        p_period_id,
        p_predicted_high,
        p_predicted_low,
        p_ton_transaction_hash
    )
    returning * into v_prediction;
    
    -- Update prize pool
    update t_prediction_periods
    set total_pool = total_pool + buy_in
    where id = p_period_id;
    
    return v_prediction;
end;
$$;

create or replace function close_prediction_period(
    p_period_id bigint,
    p_final_high numeric(20,8),
    p_final_low numeric(20,8)
)
returns table (
    wallet_address text,
    prize_amount float,
    distribution_id bigint  -- Added return value
) language plpgsql as $$
declare
    v_distribution_id bigint;
begin
    -- Update period with actual values (unchanged)
    update t_prediction_periods
    set 
        final_high = p_final_high,
        final_low = p_final_low,
        is_active = false,
        closed_at = now()
    where id = p_period_id
    and is_active = true;
    
    -- Calculate differences (unchanged)
    update t_user_predictions
    set
        high_difference = abs(predicted_high - p_final_high),
        low_difference = abs(predicted_low - p_final_low),
        total_difference = abs(predicted_high - p_final_high) + abs(predicted_low - p_final_low)
    where period_id = p_period_id;
    
    -- Create prize distribution record
    insert into t_prize_distributions (
        period_id,
        winner_wallet_address,
        prize_amount
    )
    select 
        p_period_id,
        up.wallet_address,
        pp.total_pool
    from t_user_predictions up
    join t_prediction_periods pp on up.period_id = pp.id
    where up.period_id = p_period_id
    order by up.total_difference asc
    limit 1
    returning id into v_distribution_id;
    
    -- Return winner info with distribution ID
    return query
    select 
        pd.winner_wallet_address,
        pd.prize_amount,
        pd.id as distribution_id
    from t_prize_distributions pd
    where pd.id = v_distribution_id;
end;
$$;

create or replace function get_period_leaderboard(p_period_id bigint)
returns table (
    wallet_address text,
    predicted_high numeric(20,8),
    predicted_low numeric(20,8),
    total_difference numeric(20,8),
    rank bigint
) language sql as $$
    select 
        wallet_address,
        predicted_high,
        predicted_low,
        total_difference,
        rank() over (order by total_difference asc)
    from t_user_predictions
    where period_id = p_period_id
    and total_difference is not null
    order by total_difference asc;
$$;

create or replace function get_active_periods()
returns table (
    period_id bigint,
    asset_symbol text,
    asset_name text,
    asset_logo_url text,
    starts_at timestamptz,
    ends_at timestamptz,
    buy_in float,
    total_pool float,
    prediction_count bigint
) language sql as $$
    select 
        pp.id as period_id,
        ca.symbol as asset_symbol,
        ca.name as asset_name,
        ca.logo_url as asset_logo_url,
        pp.starts_at,
        pp.ends_at,
        pp.buy_in,
        pp.total_pool,
        count(up.id) as prediction_count
    from t_prediction_periods pp
    join t_crypto_assets ca on pp.asset_id = ca.id
    left join t_user_predictions up on pp.id = up.period_id
    where pp.is_active = true
    and pp.ends_at > now()
    group by pp.id, ca.symbol, ca.name, ca.logo_url;
$$;

-- Function to get current prediction accuracy rankings
create or replace function get_current_prediction_rankings(p_period_id bigint)
returns table (
    wallet_address text,
    predicted_high numeric(20,8),
    predicted_low numeric(20,8),
    current_high numeric(20,8),
    current_low numeric(20,8),
    high_accuracy_percentage numeric(20,2),
    low_accuracy_percentage numeric(20,2),
    combined_accuracy_percentage numeric(20,2),
    rank bigint
) language sql as $$
    with prediction_accuracy as (
        select 
            up.wallet_address,
            up.predicted_high,
            up.predicted_low,
            pp.current_high,
            pp.current_low,
            -- Calculate accuracy percentage for high prediction
            (100 - abs(
                ((up.predicted_high - pp.current_high) / pp.current_high) * 100
            )) as high_accuracy_percentage,
            -- Calculate accuracy percentage for low prediction
            (100 - abs(
                ((up.predicted_low - pp.current_low) / pp.current_low) * 100
            )) as low_accuracy_percentage
        from t_user_predictions up
        join t_prediction_periods pp on up.period_id = pp.id
        where up.period_id = p_period_id
        and pp.current_high is not null
        and pp.current_low is not null
    )
    select 
        wallet_address,
        predicted_high,
        predicted_low,
        current_high,
        current_low,
        round(high_accuracy_percentage::numeric, 2) as high_accuracy_percentage,
        round(low_accuracy_percentage::numeric, 2) as low_accuracy_percentage,
        round(((high_accuracy_percentage + low_accuracy_percentage) / 2)::numeric, 2) as combined_accuracy_percentage,
        rank() over (
            order by (high_accuracy_percentage + low_accuracy_percentage) / 2 desc
        )
    from prediction_accuracy
    order by combined_accuracy_percentage desc;
$$;

create or replace function get_current_leaderboard(p_period_id bigint, p_limit integer default 10)
returns table (
    wallet_address text,
    predicted_high numeric(20,8),
    predicted_low numeric(20,8),
    combined_accuracy_percentage numeric(20,2),
    rank bigint
) language sql as $$
    select 
        wallet_address,
        predicted_high,
        predicted_low,
        combined_accuracy_percentage,
        rank
    from get_current_prediction_rankings(p_period_id)
    limit p_limit;
$$;

create or replace function get_wallet_leaderboard_position(p_period_id bigint, p_wallet_address text)
returns table (
    wallet_address text,
    predicted_high numeric(20,8),
    predicted_low numeric(20,8),
    combined_accuracy_percentage numeric(20,2),
    rank bigint
) language sql as $$
    select 
        wallet_address,
        predicted_high,
        predicted_low,
        combined_accuracy_percentage,
        rank
    from get_current_prediction_rankings(p_period_id)
    where wallet_address = p_wallet_address;
$$;

create or replace function get_user_prediction_history(
    p_wallet_address text,
    p_page_size integer default 10,
    p_page_number integer default 1
)
returns table (
    period_id bigint,
    period_start_time timestamptz,
    period_end_time timestamptz,
    final_high numeric(20,8),
    final_low numeric(20,8),
    total_pool float,
    winner_wallet_address text,
    winner_predicted_high numeric(20,8),
    winner_predicted_low numeric(20,8),
    winner_accuracy numeric(20,2),
    user_predicted_high numeric(20,8),
    user_predicted_low numeric(20,8),
    user_accuracy numeric(20,2)
) language sql as $$
    with period_winners as (
        select 
            up.period_id,
            up.wallet_address,
            up.predicted_high,
            up.predicted_low,
            case 
                when pp.final_high is not null and pp.final_low is not null then
                    round((
                        (100 - abs(((up.predicted_high - pp.final_high) / pp.final_high) * 100)) +
                        (100 - abs(((up.predicted_low - pp.final_low) / pp.final_low) * 100))
                    ) / 2, 2)
                else null
            end as accuracy
        from t_user_predictions up
        join t_prediction_periods pp on up.period_id = pp.id
        where up.total_difference = (
            select min(total_difference)
            from t_user_predictions
            where period_id = up.period_id
            and total_difference is not null
        )
    )
    select 
        pp.id as period_id,
        pp.starts_at as period_start_time,
        pp.ends_at as period_end_time,
        pp.final_high,
        pp.final_low,
        pp.total_pool,
        pw.wallet_address as winner_wallet_address,
        pw.predicted_high as winner_predicted_high,
        pw.predicted_low as winner_predicted_low,
        pw.accuracy as winner_accuracy,
        up.predicted_high as user_predicted_high,
        up.predicted_low as user_predicted_low,
        case 
            when pp.final_high is not null and pp.final_low is not null then
                round((
                    (100 - abs(((up.predicted_high - pp.final_high) / pp.final_high) * 100)) +
                    (100 - abs(((up.predicted_low - pp.final_low) / pp.final_low) * 100))
                ) / 2, 2)
            else null
        end as user_accuracy
    from t_prediction_periods pp
    left join period_winners pw on pp.id = pw.period_id
    left join t_user_predictions up on pp.id = up.period_id and up.wallet_address = p_wallet_address
    order by pp.id desc
    limit p_page_size
    offset (p_page_number - 1) * p_page_size;
$$;

-- Indexes for better query performance
create index if not exists idx_prediction_periods_active_dates on t_prediction_periods(is_active, starts_at, ends_at);
create index if not exists idx_user_predictions_period on t_user_predictions(period_id);
create index if not exists idx_user_predictions_wallet on t_user_predictions(wallet_address);
create index if not exists idx_user_predictions_period_composite on t_user_predictions(period_id, wallet_address);

-- Sample data insertion
-- insert into t_crypto_assets (symbol, name, logo_url) values 
-- ('BTC', 'Bitcoin', 'https://example.com/btc-logo.png'),
-- ('ETH', 'Ethereum', 'https://example.com/eth-logo.png');