-- Core tables
create table t_crypto_assets (
    id bigint generated by default as identity primary key,
    symbol text not null unique,
    name text not null,
    logo_url text,
    is_active boolean default true,
    created_at timestamptz default now()
);

create table t_prediction_periods (
    id bigint generated by default as identity primary key,
    asset_id bigint references t_crypto_assets(id),
    starts_at timestamptz not null,
    ends_at timestamptz not null,
    is_active boolean default true,
    buy_in float not null default 1.0,
    total_pool float default 0,
    actual_high numeric(20,8),
    actual_low numeric(20,8),
    closed_at timestamptz,
    created_at timestamptz default now()
);

create table t_user_predictions (
    id bigint generated by default as identity primary key,
    wallet_address text not null,
    period_id bigint references t_prediction_periods(id),
    predicted_high numeric(20,8) not null,
    predicted_low numeric(20,8) not null,
    ton_transaction_hash text not null unique,
    high_difference numeric(20,8),
    low_difference numeric(20,8),
    total_difference numeric(20,8),
    created_at timestamptz default now()
);

-- Indexes for better query performance
create index idx_prediction_periods_active_dates on t_prediction_periods(is_active, starts_at, ends_at);
create index idx_user_predictions_period on t_user_predictions(period_id);
create index idx_user_predictions_wallet on t_user_predictions(wallet_address);

-- Functions for game management
create or replace function submit_prediction(
    p_wallet_address text,
    p_period_id bigint,
    p_predicted_high numeric(20,8),
    p_predicted_low numeric(20,8),
    p_ton_transaction_hash text
)
returns t_user_predictions language plpgsql as $$
declare
    v_period t_prediction_periods;
    v_prediction t_user_predictions;
begin
    -- Check if period exists and is active
    select *
    into v_period
    from t_prediction_periods
    where id = p_period_id
    and is_active = true
    and starts_at <= now()
    and ends_at > now();
    
    if v_period is null then
        raise exception 'Invalid or inactive prediction period';
    end if;
    
    -- Validate prediction values
    if p_predicted_low >= p_predicted_high then
        raise exception 'Predicted low must be less than predicted high';
    end if;
    
    -- Create prediction and update pool
    insert into t_user_predictions (
        wallet_address,
        period_id,
        predicted_high,
        predicted_low,
        ton_transaction_hash
    ) values (
        p_wallet_address,
        p_period_id,
        p_predicted_high,
        p_predicted_low,
        p_ton_transaction_hash
    )
    returning * into v_prediction;
    
    -- Update prize pool
    update t_prediction_periods
    set total_pool = total_pool + buy_in
    where id = p_period_id;
    
    return v_prediction;
end;
$$;

create or replace function close_prediction_period(
    p_period_id bigint,
    p_actual_high numeric(20,8),
    p_actual_low numeric(20,8)
)
returns table (
    wallet_address text,
    prize_amount float
) language plpgsql as $$
begin
    -- Update period with actual values
    update t_prediction_periods
    set 
        actual_high = p_actual_high,
        actual_low = p_actual_low,
        is_active = false,
        closed_at = now()
    where id = p_period_id
    and is_active = true;
    
    -- Calculate differences for all predictions
    update t_user_predictions
    set
        high_difference = abs(predicted_high - p_actual_high),
        low_difference = abs(predicted_low - p_actual_low),
        total_difference = abs(predicted_high - p_actual_high) + abs(predicted_low - p_actual_low)
    where period_id = p_period_id;
    
    -- Return winner
    return query
    select 
        up.wallet_address,
        pp.total_pool as prize_amount
    from t_user_predictions up
    join t_prediction_periods pp on up.period_id = pp.id
    where up.period_id = p_period_id
    order by up.total_difference asc
    limit 1;
end;
$$;

create or replace function get_period_leaderboard(p_period_id bigint)
returns table (
    wallet_address text,
    predicted_high numeric(20,8),
    predicted_low numeric(20,8),
    total_difference numeric(20,8),
    rank bigint
) language sql as $$
    select 
        wallet_address,
        predicted_high,
        predicted_low,
        total_difference,
        rank() over (order by total_difference asc)
    from t_user_predictions
    where period_id = p_period_id
    and total_difference is not null
    order by total_difference asc;
$$;

create or replace function get_active_periods()
returns table (
    period_id bigint,
    asset_symbol text,
    asset_name text,
    asset_logo_url text,
    starts_at timestamptz,
    ends_at timestamptz,
    buy_in float,
    total_pool float,
    prediction_count bigint
) language sql as $$
    select 
        pp.id as period_id,
        ca.symbol as asset_symbol,
        ca.name as asset_name,
        ca.logo_url as asset_logo_url,
        pp.starts_at,
        pp.ends_at,
        pp.buy_in,
        pp.total_pool,
        count(up.id) as prediction_count
    from t_prediction_periods pp
    join t_crypto_assets ca on pp.asset_id = ca.id
    left join t_user_predictions up on pp.id = up.period_id
    where pp.is_active = true
    and pp.ends_at > now()
    group by pp.id, ca.symbol, ca.name, ca.logo_url;
$$;

-- Sample data insertion
insert into t_crypto_assets (symbol, name, logo_url) values 
('BTC', 'Bitcoin', 'https://example.com/btc-logo.png'),
('ETH', 'Ethereum', 'https://example.com/eth-logo.png');